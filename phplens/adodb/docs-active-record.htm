<html>
<style>
pre {
  background-color: #eee;
  padding: 0.75em 1.5em;
  font-size: 12px;
  border: 1px solid #ddd;
}

li,p {
font-family: Arial, Helvetica, sans-serif ;
}
</style>
<body>
<h1>ADOdb Active Record</h1>
<p> (c) 2000-2006 John Lim (jlim#natsoft.com)</p>
<p><font size="1">This software is dual licensed using BSD-Style and LGPL. This 
  means you can use it in compiled proprietary and commercial products.</font></p>
<p>
<b>WARNING: THIS IS AN ALPHA IMPLEMENTATION, AND THOUGH I HAVE TRIED TO TEST IT EXTENSIVELY,  THERE COULD BE BUGS IN IT STILL.</b>
<hr>
<p>Download: <a href=http://phplens.com/lens/dl/active-record-000.zip>zip</a>. The included <i>active-record-readme.txt</i> has installation instructions.
<h3>Introduction</h3>
<p>
ADOdb_Active_Record is an implementation similar to <a href=http://framework.zend.com/manual/zend.db.dataobject.html>Zend_Db_DataObject</a> for Object Relation Mapping (ORM) using PHP. In an ORM system, the tables and rows of the database are abstracted into native PHP objects. This allows the programmer to focus more on manipulating the data and less on writing SQL queries.
<p>
This implementation differs from Zend_Db_DataObject in the following ways:
<ul>
<li>Works with PHP4 and PHP5 and provides equivalent functionality in both versions of PHP. Zend_Db_DataObject only works with PHP5.<p>
<li>Function names similar to Zend_Db_DataObject for easy porting, with extensions such as Load() and Replace().<p>
<li>ADodb_Active_Record works when you are connected to multiple databases. Zend_Db_DataObject only works when connected to a default database.<p>
<li>Support for $ADODB_ASSOC_CASE. The field names are upper-cased, lower-cased or left in natural case depending on this setting.<p>
<li>No field name conversion to camel-caps style, unlike Zend's implementation which will convert field names such as 'first_name' to 'firstName'.<p>
<li>New ADOConnection::GetActiveRecords() and ADOConnection::GetActiveRecordsClass() functions in adodb.inc.php.<p>

<li>Caching of table metadata so it is only queried once per table, no matter how many Active Records are created.<p>
<li>The additional functionality is described <a href=#additional>below</a>. 
</ul>
<P>
ADodb_Active_Record is designed upon the principles of the "ActiveRecord" design pattern, which was first described by Martin Fowler. The ActiveRecord pattern has been implemented in many forms across the spectrum of programming languages. ADodb_Active_Record attempts to represent the database as closely to native PHP objects as possible.
<p>
ADodb_Active_Record maps a database table to a PHP class, and each instance of that class represents a table row. Relations between tables can also be defined, allowing the ADodb_Active_Record objects to be nested.
<p>

<h3>Setting the Database Connection</h3>
<p>
The first step to using  ADodb_Active_Record is to set the default connection that an ADodb_Active_Record objects will use to connect to a database. 

<pre>
require_once('adodb/adodb-active-record.php');

$db = new ADOConnection('mysql://root:pwd@localhost/dbname');
ADOdb_Active_Record::SetDatabaseAdapter($db);
</pre>        

<h3>Table Rows as Objects</h3>
<p>
First, let's create a temporary table in our MySQL database that we can use for demonstrative purposes throughout the rest of this tutorial. We can do this by sending a CREATE query:

<pre>
$db->Execute("CREATE TEMPORARY TABLE `persons` (
                `id` int(10) unsigned NOT NULL auto_increment,
                `name_first` varchar(100) NOT NULL default '',
                `name_last` varchar(100) NOT NULL default '',
                `favorite_color` varchar(100) NOT NULL default '',
                PRIMARY KEY  (`id`)
            ) ENGINE=MyISAM;
           ");
 </pre>   
<p>
ADOdb_Active_Record's are object representations of table rows. Each table in the database is represented by a class in PHP. To begin working with a table as a ADOdb_Active_Record, a class that extends ADOdb_Active_Records needs to be created for it.

<pre>
class Person extends ADOdb_Active_Record{}
$person = new Person();
</pre>   

<p>
In the above example, a new ADOdb_Active_Record object $person was created to access the "persons" table. Zend_Db_DataObject takes the name of the class, pluralizes it (according to American English rules), and assumes that this is the name of the table in the database.
<p>
This kind of behavior is typical of ADOdb_Active_Record. It will assume as much as possible by convention rather than explicit configuration. In situations where it isn't possible to use the conventions that ADOdb_Active_Record expects, options can be overridden as we'll see later.
<h3>Table Columns as Object Properties</h3>
<p>
When the $person object was instantiated, ADOdb_Active_Record read the table metadata from the database itself, and then exposed the table's columns (fields) as object properties.
<p>
Our "persons" table has three fields: "name_first", "name_last", and "favorite_color". Each of these fields is now a property of the $person object. To see all these properties, use the ADOdb_Active_Record::getAttributeNames() method:
<pre>
var_dump($person->getAttributeNames());

/**
 * Outputs the following:
 * array(4) {
 *    [0]=>
 *    string(2) "id"
 *    [1]=>
 *    string(9) "name_first"
 *    [2]=>
 *    string(8) "name_last"
 *    [3]=>
 *    string(13) "favorite_color"
 *  }
 */
    </pre>   
<p>
One big difference between ADOdb and Zend's implementation is we do not automatically convert to camelCaps style.
<p>
<h3> Inserting and Updating a Record</h3><p>

A ADOdb_Active_Record object is a representation of a single table row. However, when our $person object is instantiated, it does not reference any particular row. It is a blank record that does not yet exist in the database. A ADOdb_Active_Record object is considered blank when its primary key is NULL. The primary key in our persons table is "id".
<p>
To insert a new record into the database, change the object's properties and then call the ADOdb_Active_Record::save() method:
<pre>
$person = new Person();
$person->nameFirst = 'Andi';
$person->nameLast  = 'Gutmans';
$person->save();
 </pre>   
<p>
Oh, no! The above code snippet does not insert a new record into the database. Instead, outputs an error:
<pre>
1048: Column 'name_first' cannot be null
 </pre>   
<p>
This error occurred because MySQL rejected the INSERT query that was generated by ADOdb_Active_Record. If exceptions are enabled in ADOdb and you are using PHP5, an error will be thrown. In the definition of our table, we specified all of the fields as NOT NULL; i.e., they must contain a value.
<p>
ADOdb_Active_Records are bound by the same contraints as the database tables they represent. If the field in the database cannot be NULL, the corresponding property in the ADOdb_Active_Record also cannot be NULL. In the example above, we failed to set the property $person->favoriteColor, which caused the INSERT to be rejected by MySQL.
<p>
To insert a new ADOdb_Active_Record in the database, populate all of ADOdb_Active_Record's properties so that they satisfy the constraints of the database table, and then call the save() method:
<pre>
/**
 * Calling the save() method will successfully INSERT
 * this $person into the database table.
 */
$person = new Person();
$person->name_first     = 'Andi';
$person->name_last      = 'Gutmans';
$person->favorite_color = 'blue';
$person->save();
</pre>
<p>
Once this $person has been INSERTed into the database by calling save(), the primary key can now be read as a property. Since this is the first row inserted into our temporary table, its "id" will be 1:
<pre>
var_dump($person->id);

/**
 * Outputs the following:
 * string(1)
 */
 </pre>       
<p>
From this point on, updating it is simply a matter of changing the object's properties and calling the save() method again:

<pre>
$person->favorite_color = 'red';
$person->save();
   </pre>
<p>
The code snippet above will change the favorite color to red, and then UPDATE the record in the database.

<a name=additional>
<h2>ADOdb Specific Functionality</h2>
<h3>Setting the Table Name</h3>
<p>The default behaviour on creating an ADOdb_Active_Record is to "pluralize" the class name and use that as the table name. Often, this is not the case. For example, the Person class could be reading from the "People" table. We provide a constructor parameter to override the default table naming behaviour.
<pre>
	class Person extends ADOdb_Active_Record{}
	$person = new Person('People');
</pre>
<h3>$ADODB_ASSOC_CASE</h3>
<p>This allows you to control the case of field names and properties. For example, all field names in Oracle are upper-case by default. So you 
can force field names to be lowercase using $ADODB_ASSOC_CASE. Legal values are as follows:
<pre>
  0: lower-case
  1: upper-case
  2: native-case
</pre>
<p>So to force all Oracle field names to lower-case, use
<pre>
	$ADODB_ASSOC_CASE = 0;
	$person = new Person('People');
	$person->name = 'Lily';
	$ADODB_ASSOC_CASE = 2;
	$person2 = new Person('People');
	$person2->NAME = 'Lily'; 
</pre>

<p>Also see <a href=http://phplens.com/adodb/reference.constants.adodb_assoc_case.html>$ADODB_ASSOC_CASE</a>.
<h3>Replace</h3>
<p>
ADOdb supports replace functionality, whereby the record is inserted if it does not exists, or updated otherwise.
<pre>
$rec = new ADODB_Active_Record("product");
$rec->name = 'John';
$rec->tel_no = '34111145';
$ok = $rec->replace(); // 0=failure, 1=update, 2=insert
</pre>
<h3>Load</h3>
<p>Sometimes, we want to load a single record into an Active Record. We can do so using:
<pre>
$person->load("id=3");

// or using bind parameters

$person->load("id=?", array(3));
</pre>
<p>Returns false if an error occurs.

<h3>ADOConnection->GetActiveRecords()</h3>
<p>
This allows you to retrieve an array of ADOdb_Active_Records
<pre>
$table = 'products';
$whereOrderBy = "name LIKE 'A%' ORDER BY Name";
$activeRecArr = $db->GetActiveRecords($table, $whereOrderBy);
foreach($activeRecArr as $rec) {
	$rec->id = rand();
	$rec->save();
}
</pre>
<p>
And to retrieve all records ordered by specific fields:
<pre>
$whereOrderBy = "1=1 ORDER BY Name";
$activeRecArr = $db->ADOdb_Active_Records($table);
</pre>
<p>Returns false if an error occurs.

<h3>ADOConnection->GetActiveRecordsClass()</h3>
<p>
This allows you to retrieve an array of objects derived from ADOdb_Active_Records.
<pre>
class Product extends ADODB_Active_Records{};
$table = 'products';
$whereOrderBy = "name LIKE 'A%' ORDER BY Name";
$activeRecArr = $db->GetActiveRecordsClass('Product',$table, $whereOrderBy);

# the objects in $activeRecArr are of class 'Product'
foreach($activeRecArr as $rec) {
	$rec->id = rand();
	$rec->save();
}
</pre>
<h3>Dealing with Multiple Databases</h3>
<p>
Sometimes we want to load  data from one database and insert it into another using ActiveRecords. This can be done using the 2nd optional parameter of the ADOdb_Active_Record constructor. In the following example, we read data from db.table1 and store it in db2.table2:
<pre>
$db = NewADOConnection(...);
$db2 = NewADOConnection(...);

ADOdb_Active_Record::SetDatabaseAdapter($db2);

$activeRecs = $db->GetActiveRecords('table1');

foreach($activeRecs as $rec) {
	$rec2 = new ADOdb_Active_Record('table2',$db2);
	$rec2->id = $rec->id;
	$rec2->name = $rec->name;
	
	$rec2->Save();
}
</pre>
<h3>Limitations of Software</h3>
<p>
This is a alpha release and ADodb_Active_Record might have bugs. 
<p>One known limitation is that retrieval of the last auto-incrementing ID is not reliable for databases that do not support the Insert_ID() function call; in this case we perform a <b>SELECT MAX($primarykey) FROM $table</b>, which will not work reliably in a multi-user environment. You can override the ADODB_Active_Record::LastInsertID() function in this case.
<h2>Code Sample</h2>
<p>The following works with PHP4 and PHP5
<pre>
	include('../adodb.inc.php');
	include('../adodb-active-record.inc.php');
	
	// uncomment the following if you want to test exceptions
	#if (PHP_VERSION >= 5) include('../adodb-exceptions.inc.php');

	$db = NewADOConnection('mysql://root@localhost/northwind');
	$db->debug=1;
	ADOdb_Active_Record::SetDatabaseAdapter($db);

	$db->Execute("CREATE TEMPORARY TABLE `persons` (
	                `id` int(10) unsigned NOT NULL auto_increment,
	                `name_first` varchar(100) NOT NULL default '',
	                `name_last` varchar(100) NOT NULL default '',
	                `favorite_color` varchar(100) NOT NULL default '',
	                PRIMARY KEY  (`id`)
	            ) ENGINE=MyISAM;
	           ");
			   
	class Person extends ADOdb_Active_Record{}
	$person = new Person();
	
	echo "&lt;p>Output of getAttributeNames: ";
	var_dump($person->getAttributeNames());
	
	/**
	 * Outputs the following:
	 * array(4) {
	 *    [0]=>
	 *    string(2) "id"
	 *    [1]=>
	 *    string(9) "name_first"
	 *    [2]=>
	 *    string(8) "name_last"
	 *    [3]=>
	 *    string(13) "favorite_color"
	 *  }
	 */
	
	$person = new Person();
	$person->nameFirst = 'Andi';
	$person->nameLast  = 'Gutmans';
	$person->save(); // this save() will fail on INSERT as favorite_color is a must fill...
	
	
	$person = new Person();
	$person->name_first     = 'Andi';
	$person->name_last      = 'Gutmans';
	$person->favorite_color = 'blue';
	$person->save(); // this save will perform an INSERT successfully
	
	echo "&lt;p>The Insert ID generated:"; print_r($person->id);
	
	$person->favorite_color = 'red';
	$person->save(); // this save() will perform an UPDATE
	
	// load record where id=1 into a new ADODB_Active_Record
	$person2 = new Person();
	$person2->Load('id=1');
	
	var_dump($person2);
</pre>

 <h3>Todo</h3>
 <p>Check _original and current field values before update, only update changes.
 <p>Handle 1-to-many relationships.
<h3> Change Log</h3>
<p>
 0.01 To be released 2006<br>
- Fixed handling of nulls when saving (it didn't save nulls, saved them as '').<br>
- Better error handling messages.<br>
- Factored out a new method GetPrimaryKeys().<br>
 <p>
 0.00 5 Mar 2006<br>
 1st release
</body>
</html>